// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/libdevfile/libdevfile.go

// Package libdevfile is a generated GoMock package.
package libdevfile

import (
	context "context"
	reflect "reflect"

	v1alpha2 "github.com/devfile/api/v2/pkg/apis/workspaces/v1alpha2"
	gomock "github.com/golang/mock/gomock"
)

// MockHandler is a mock of Handler interface.
type MockHandler struct {
	ctrl     *gomock.Controller
	recorder *MockHandlerMockRecorder
}

// MockHandlerMockRecorder is the mock recorder for MockHandler.
type MockHandlerMockRecorder struct {
	mock *MockHandler
}

// NewMockHandler creates a new mock instance.
func NewMockHandler(ctrl *gomock.Controller) *MockHandler {
	mock := &MockHandler{ctrl: ctrl}
	mock.recorder = &MockHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHandler) EXPECT() *MockHandlerMockRecorder {
	return m.recorder
}

// ApplyImage mocks base method.
func (m *MockHandler) ApplyImage(image v1alpha2.Component) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplyImage", image)
	ret0, _ := ret[0].(error)
	return ret0
}

// ApplyImage indicates an expected call of ApplyImage.
func (mr *MockHandlerMockRecorder) ApplyImage(image interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplyImage", reflect.TypeOf((*MockHandler)(nil).ApplyImage), image)
}

// ApplyKubernetes mocks base method.
func (m *MockHandler) ApplyKubernetes(kubernetes v1alpha2.Component, kind v1alpha2.CommandGroupKind) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplyKubernetes", kubernetes, kind)
	ret0, _ := ret[0].(error)
	return ret0
}

// ApplyKubernetes indicates an expected call of ApplyKubernetes.
func (mr *MockHandlerMockRecorder) ApplyKubernetes(kubernetes, kind interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplyKubernetes", reflect.TypeOf((*MockHandler)(nil).ApplyKubernetes), kubernetes, kind)
}

// ApplyOpenShift mocks base method.
func (m *MockHandler) ApplyOpenShift(openshift v1alpha2.Component, kind v1alpha2.CommandGroupKind) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplyOpenShift", openshift, kind)
	ret0, _ := ret[0].(error)
	return ret0
}

// ApplyOpenShift indicates an expected call of ApplyOpenShift.
func (mr *MockHandlerMockRecorder) ApplyOpenShift(openshift, kind interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplyOpenShift", reflect.TypeOf((*MockHandler)(nil).ApplyOpenShift), openshift, kind)
}

// ExecuteNonTerminatingCommand mocks base method.
func (m *MockHandler) ExecuteNonTerminatingCommand(ctx context.Context, command v1alpha2.Command) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteNonTerminatingCommand", ctx, command)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecuteNonTerminatingCommand indicates an expected call of ExecuteNonTerminatingCommand.
func (mr *MockHandlerMockRecorder) ExecuteNonTerminatingCommand(ctx, command interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteNonTerminatingCommand", reflect.TypeOf((*MockHandler)(nil).ExecuteNonTerminatingCommand), ctx, command)
}

// ExecuteTerminatingCommand mocks base method.
func (m *MockHandler) ExecuteTerminatingCommand(ctx context.Context, command v1alpha2.Command) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteTerminatingCommand", ctx, command)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecuteTerminatingCommand indicates an expected call of ExecuteTerminatingCommand.
func (mr *MockHandlerMockRecorder) ExecuteTerminatingCommand(ctx, command interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteTerminatingCommand", reflect.TypeOf((*MockHandler)(nil).ExecuteTerminatingCommand), ctx, command)
}
