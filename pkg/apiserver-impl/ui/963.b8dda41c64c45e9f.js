"use strict";(self.webpackChunkdevfile_builder=self.webpackChunkdevfile_builder||[]).push([[963],{7416:(p,P,E)=>{E.d(P,{c:()=>b});var O=E(9948),N=E(4258);const T=function i(u){return(0,N.Z)(u,4)};var S=E(2957);function b(u){var g={options:{directed:u.isDirected(),multigraph:u.isMultigraph(),compound:u.isCompound()},nodes:B(u),edges:R(u)};return O.Z(u.graph())||(g.value=T(u.graph())),g}function B(u){return S.Z(u.nodes(),function(g){var v=u.node(g),y=u.parent(g),D={v:g};return O.Z(v)||(D.value=v),O.Z(y)||(D.parent=y),D})}function R(u){return S.Z(u.edges(),function(g){var v=u.edge(g),y={v:g.v,w:g.w};return O.Z(g.name)||(y.name=g.name),O.Z(v)||(y.value=v),y})}E(1595)},5963:(p,P,E)=>{E.d(P,{r:()=>G});var O=E(9006),N=E(7416),w=E(3330),i=E(855),T=E(8814),S=E(5703);let o={},b={},B={};const X=(n,t)=>(i.l.trace("In isDecendant",t," ",n," = ",b[t].includes(n)),!!b[t].includes(n)),g=(n,t,e,r)=>{i.l.warn("Copying children of ",n,"root",r,"data",t.node(n),r);const s=t.children(n)||[];n!==r&&s.push(n),i.l.warn("Copying (nodes) clusterId",n,"nodes",s),s.forEach(l=>{if(t.children(l).length>0)g(l,t,e,r);else{const f=t.node(l);i.l.info("cp ",l," to ",r," with parent ",n),e.setNode(l,f),r!==t.parent(l)&&(i.l.warn("Setting parent",l,t.parent(l)),e.setParent(l,t.parent(l))),n!==r&&l!==n?(i.l.debug("Setting parent",l,n),e.setParent(l,n)):(i.l.info("In copy ",n,"root",r,"data",t.node(n),r),i.l.debug("Not Setting parent for node=",l,"cluster!==rootId",n!==r,"node!==clusterId",l!==n));const d=t.edges(l);i.l.debug("Copying Edges",d),d.forEach(h=>{i.l.info("Edge",h);const x=t.edge(h.v,h.w,h.name);i.l.info("Edge data",x,r);try{((n,t)=>(i.l.info("Decendants of ",t," is ",b[t]),i.l.info("Edge is ",n),n.v!==t&&n.w!==t&&(b[t]?b[t].includes(n.v)||X(n.v,t)||X(n.w,t)||b[t].includes(n.w):(i.l.debug("Tilt, ",t,",not in decendants"),!1))))(h,r)?(i.l.info("Copying as ",h.v,h.w,x,h.name),e.setEdge(h.v,h.w,x,h.name),i.l.info("newGraph edges ",e.edges(),e.edge(e.edges()[0]))):i.l.info("Skipping copy of edge ",h.v,"--\x3e",h.w," rootId: ",r," clusterId:",n)}catch(m){i.l.error(m)}})}i.l.debug("Removing node",l),t.removeNode(l)})},v=(n,t)=>{const e=t.children(n);let r=[...e];for(const s of e)B[s]=n,r=[...r,...v(s,t)];return r},y=(n,t)=>{i.l.trace("Searching",n);const e=t.children(n);if(i.l.trace("Searching children of id ",n,e),e.length<1)return i.l.trace("This is a valid node",n),n;for(const r of e){const s=y(r,t);if(s)return i.l.trace("Found replacement for",n," => ",s),s}},D=n=>o[n]&&o[n].externalConnections&&o[n]?o[n].id:n,J=(n,t)=>{if(i.l.warn("extractor - ",t,N.c(n),n.children("D")),t>10)return void i.l.error("Bailing out");let e=n.nodes(),r=!1;for(const s of e){const l=n.children(s);r=r||l.length>0}if(r){i.l.debug("Nodes = ",e,t);for(const s of e)if(i.l.debug("Extracting node",s,o,o[s]&&!o[s].externalConnections,!n.parent(s),n.node(s),n.children("D")," Depth ",t),o[s])if(!o[s].externalConnections&&n.children(s)&&n.children(s).length>0){i.l.warn("Cluster without external connections, without a parent and with children",s,t);let f="TB"===n.graph().rankdir?"LR":"TB";o[s]&&o[s].clusterData&&o[s].clusterData.dir&&(f=o[s].clusterData.dir,i.l.warn("Fixing dir",o[s].clusterData.dir,f));const d=new T.k({multigraph:!0,compound:!0}).setGraph({rankdir:f,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.l.warn("Old graph before copy",N.c(n)),g(s,n,d,s),n.setNode(s,{clusterNode:!0,id:s,clusterData:o[s].clusterData,labelText:o[s].labelText,graph:d}),i.l.warn("New graph after copy node: (",s,")",N.c(d)),i.l.debug("Old graph after copy",N.c(n))}else i.l.warn("Cluster ** ",s," **not meeting the criteria !externalConnections:",!o[s].externalConnections," no parent: ",!n.parent(s)," children ",n.children(s)&&n.children(s).length>0,n.children("D"),t),i.l.debug(o);else i.l.debug("Not a cluster",s,t);e=n.nodes(),i.l.warn("New list of nodes",e);for(const s of e){const l=n.node(s);i.l.warn(" Now next level",s,l),l.clusterNode&&J(l.graph,t+1)}}else i.l.debug("Done, no node has children",n.nodes())},M=(n,t)=>{if(0===t.length)return[];let e=Object.assign(t);return t.forEach(r=>{const s=n.children(r),l=M(n,s);e=[...e,...l]}),e},Z={rect:(n,t)=>{i.l.trace("Creating subgraph rect for ",t.id,t);const e=n.insert("g").attr("class","cluster"+(t.class?" "+t.class:"")).attr("id",t.id),r=e.insert("rect",":first-child"),s=e.insert("g").attr("class","cluster-label"),l=s.node().appendChild((0,w.c)(t.labelText,t.labelStyle,void 0,!0));let f=l.getBBox();if((0,i.j)((0,i.g)().flowchart.htmlLabels)){const c=l.children[0],a=(0,S.Ys)(l);f=c.getBoundingClientRect(),a.attr("width",f.width),a.attr("height",f.height)}const d=0*t.padding,h=d/2,x=t.width<=f.width+d?f.width+d:t.width;t.diff=t.width<=f.width+d?(f.width-t.width)/2-t.padding/2:-t.padding/2,i.l.trace("Data ",t,JSON.stringify(t)),r.attr("style",t.style).attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-x/2).attr("y",t.y-t.height/2-h).attr("width",x).attr("height",t.height+d),s.attr("transform","translate("+(t.x-f.width/2)+", "+(t.y-t.height/2)+")");const m=r.node().getBBox();return t.width=m.width,t.height=m.height,t.intersect=function(c){return(0,w.i)(t,c)},e},roundedWithTitle:(n,t)=>{const e=n.insert("g").attr("class",t.classes).attr("id",t.id),r=e.insert("rect",":first-child"),s=e.insert("g").attr("class","cluster-label"),l=e.append("rect"),f=s.node().appendChild((0,w.c)(t.labelText,t.labelStyle,void 0,!0));let d=f.getBBox();if((0,i.j)((0,i.g)().flowchart.htmlLabels)){const a=f.children[0],C=(0,S.Ys)(f);d=a.getBoundingClientRect(),C.attr("width",d.width),C.attr("height",d.height)}d=f.getBBox();const h=0*t.padding,x=h/2,m=t.width<=d.width+t.padding?d.width+t.padding:t.width;t.diff=t.width<=d.width+t.padding?(d.width+0*t.padding-t.width)/2:-t.padding/2,r.attr("class","outer").attr("x",t.x-m/2-x).attr("y",t.y-t.height/2-x).attr("width",m+h).attr("height",t.height+h),l.attr("class","inner").attr("x",t.x-m/2-x).attr("y",t.y-t.height/2-x+d.height-1).attr("width",m+h).attr("height",t.height+h-d.height-3),s.attr("transform","translate("+(t.x-d.width/2)+", "+(t.y-t.height/2-t.padding/3+((0,i.j)((0,i.g)().flowchart.htmlLabels)?5:3))+")");const c=r.node().getBBox();return t.height=c.height,t.intersect=function(a){return(0,w.i)(t,a)},e},noteGroup:(n,t)=>{const e=n.insert("g").attr("class","note-cluster").attr("id",t.id),r=e.insert("rect",":first-child"),s=0*t.padding,l=s/2;r.attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-t.width/2-l).attr("y",t.y-t.height/2-l).attr("width",t.width+s).attr("height",t.height+s).attr("fill","none");const f=r.node().getBBox();return t.width=f.width,t.height=f.height,t.intersect=function(d){return(0,w.i)(t,d)},e},divider:(n,t)=>{const e=n.insert("g").attr("class",t.classes).attr("id",t.id),r=e.insert("rect",":first-child"),s=0*t.padding,l=s/2;r.attr("class","divider").attr("x",t.x-t.width/2-l).attr("y",t.y-t.height/2).attr("width",t.width+s).attr("height",t.height+s);const f=r.node().getBBox();return t.width=f.width,t.height=f.height,t.diff=-t.padding/2,t.intersect=function(d){return(0,w.i)(t,d)},e}};let j={};const A=(n,t,e,r)=>{i.l.info("Graph in recursive render: XXX",N.c(t),r);const s=t.graph().rankdir;i.l.trace("Dir in recursive render - dir:",s);const l=n.insert("g").attr("class","root");t.nodes()?i.l.info("Recursive render XXX",t.nodes()):i.l.info("No nodes found for",t),t.edges().length>0&&i.l.trace("Recursive edges",t.edge(t.edges()[0]));const f=l.insert("g").attr("class","clusters"),d=l.insert("g").attr("class","edgePaths"),h=l.insert("g").attr("class","edgeLabels"),x=l.insert("g").attr("class","nodes");t.nodes().forEach(function(c){const a=t.node(c);if(void 0!==r){const C=JSON.parse(JSON.stringify(r.clusterData));i.l.info("Setting data for cluster XXX (",c,") ",C,r),t.setNode(r.id,C),t.parent(c)||(i.l.trace("Setting parent",c,r.id),t.setParent(c,r.id,C))}if(i.l.info("(Insert) Node XXX"+c+": "+JSON.stringify(t.node(c))),a&&a.clusterNode){i.l.info("Cluster identified",c,a.width,t.node(c));const C=A(x,a.graph,e,t.node(c)),L=C.elem;(0,w.u)(a,L),a.diff=C.diff||0,i.l.info("Node bounds (abc123)",c,a,a.width,a.x,a.y),(0,w.s)(L,a),i.l.warn("Recursive render complete ",L,a)}else t.children(c).length>0?(i.l.info("Cluster - the non recursive path XXX",c,a.id,a,t),i.l.info(y(a.id,t)),o[a.id]={id:y(a.id,t),node:a}):(i.l.info("Node - the non recursive path",c,a.id,a),(0,w.e)(x,t.node(c),s))}),t.edges().forEach(function(c){const a=t.edge(c.v,c.w,c.name);i.l.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(c)),i.l.info("Edge "+c.v+" -> "+c.w+": ",c," ",JSON.stringify(t.edge(c))),i.l.info("Fix",o,"ids:",c.v,c.w,"Translateing: ",o[c.v],o[c.w]),(0,w.f)(h,a)}),t.edges().forEach(function(c){i.l.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(c))}),i.l.info("#############################################"),i.l.info("###                Layout                 ###"),i.l.info("#############################################"),i.l.info(t),(0,O.bK)(t),i.l.info("Graph after layout:",N.c(t));let m=0;return(n=>M(n,n.children()))(t).forEach(function(c){const a=t.node(c);i.l.info("Position "+c+": "+JSON.stringify(t.node(c))),i.l.info("Position "+c+": ("+a.x,","+a.y,") width: ",a.width," height: ",a.height),a&&a.clusterNode?(0,w.p)(a):t.children(c).length>0?(((n,t)=>{i.l.trace("Inserting cluster"),j[t.id]=Z[t.shape||"rect"](n,t)})(f,a),o[a.id].node=a):(0,w.p)(a)}),t.edges().forEach(function(c){const a=t.edge(c);i.l.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(a),a);const C=(0,w.g)(d,c,a,o,e,t);(0,w.h)(a,C)}),t.nodes().forEach(function(c){const a=t.node(c);i.l.info(c,a.type,a.diff),"group"===a.type&&(m=a.diff)}),{elem:l,diff:m}},G=(n,t,e,r,s)=>{(0,w.a)(n,e,r,s),(0,w.b)(),(0,w.d)(),j={},b={},B={},o={},i.l.warn("Graph at first:",N.c(t)),((n,t)=>{n?(i.l.debug("Opting in, graph "),n.nodes().forEach(function(e){n.children(e).length>0&&(i.l.warn("Cluster identified",e," Replacement id in edges: ",y(e,n)),b[e]=v(e,n),o[e]={id:y(e,n),clusterData:n.node(e)})}),n.nodes().forEach(function(e){const r=n.children(e),s=n.edges();r.length>0?(i.l.debug("Cluster identified",e,b),s.forEach(l=>{l.v!==e&&l.w!==e&&X(l.v,e)^X(l.w,e)&&(i.l.warn("Edge: ",l," leaves cluster ",e),i.l.warn("Decendants of XXX ",e,": ",b[e]),o[e].externalConnections=!0)})):i.l.debug("Not a cluster ",e,b)}),n.edges().forEach(function(e){const r=n.edge(e);i.l.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),i.l.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(n.edge(e)));let s=e.v,l=e.w;if(i.l.warn("Fix XXX",o,"ids:",e.v,e.w,"Translating: ",o[e.v]," --- ",o[e.w]),o[e.v]&&o[e.w]&&o[e.v]===o[e.w]){i.l.warn("Fixing and trixing link to self - removing XXX",e.v,e.w,e.name),i.l.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),s=D(e.v),l=D(e.w),n.removeEdge(e.v,e.w,e.name);const f=e.w+"---"+e.v;n.setNode(f,{domId:f,id:f,labelStyle:"",labelText:r.label,padding:0,shape:"labelRect",style:""});const d=JSON.parse(JSON.stringify(r)),h=JSON.parse(JSON.stringify(r));d.label="",d.arrowTypeEnd="none",h.label="",d.fromCluster=e.v,h.toCluster=e.v,n.setEdge(s,f,d,e.name+"-cyclic-special"),n.setEdge(f,l,h,e.name+"-cyclic-special")}else(o[e.v]||o[e.w])&&(i.l.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),s=D(e.v),l=D(e.w),n.removeEdge(e.v,e.w,e.name),s!==e.v&&(r.fromCluster=e.v),l!==e.w&&(r.toCluster=e.w),i.l.warn("Fix Replacing with XXX",s,l,e.name),n.setEdge(s,l,r,e.name))}),i.l.warn("Adjusted Graph",N.c(n)),J(n,0),i.l.trace(o)):i.l.debug("Opting out, no graph ")})(t),i.l.warn("Graph after:",N.c(t)),A(n,t,r)}}}]);