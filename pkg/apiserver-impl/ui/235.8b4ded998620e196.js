"use strict";(self.webpackChunkdevfile_builder=self.webpackChunkdevfile_builder||[]).push([[235],{317:(K,X,x)=>{x.d(X,{c:()=>i});var b=x(9948),S=x(1410),m=x(2957);function i(l){var h={options:{directed:l.isDirected(),multigraph:l.isMultigraph(),compound:l.isCompound()},nodes:R(l),edges:p(l)};return b.Z(l.graph())||(h.value=S.Z(l.graph())),h}function R(l){return m.Z(l.nodes(),function(h){var v=l.node(h),O=l.parent(h),P={v:h};return b.Z(v)||(P.value=v),b.Z(O)||(P.parent=O),P})}function p(l){return m.Z(l.edges(),function(h){var v=l.edge(h),O={v:h.v,w:h.w};return b.Z(h.name)||(O.name=h.name),b.Z(v)||(O.value=v),O})}x(1595)},1410:(K,X,x)=>{x.d(X,{Z:()=>g});var b=x(4258);const g=function m(i){return(0,b.Z)(i,4)}},8235:(K,X,x)=>{x.d(X,{r:()=>Q});var b=x(5861),S=x(1065),m=x(317),g=x(1196),i=x(8080),R=x(8814),p=x(4118),A=x(8586);let l={},h={},v={};const P=(n,e)=>(i.l.trace("In isDescendant",e," ",n," = ",h[e].includes(n)),!!h[e].includes(n)),U=(n,e,t,c)=>{i.l.warn("Copying children of ",n,"root",c,"data",e.node(n),c);const s=e.children(n)||[];n!==c&&s.push(n),i.l.warn("Copying (nodes) clusterId",n,"nodes",s),s.forEach(r=>{if(e.children(r).length>0)U(r,e,t,c);else{const f=e.node(r);i.l.info("cp ",r," to ",c," with parent ",n),t.setNode(r,f),c!==e.parent(r)&&(i.l.warn("Setting parent",r,e.parent(r)),t.setParent(r,e.parent(r))),n!==c&&r!==n?(i.l.debug("Setting parent",r,n),t.setParent(r,n)):(i.l.info("In copy ",n,"root",c,"data",e.node(n),c),i.l.debug("Not Setting parent for node=",r,"cluster!==rootId",n!==c,"node!==clusterId",r!==n));const u=e.edges(r);i.l.debug("Copying Edges",u),u.forEach(a=>{i.l.info("Edge",a);const E=e.edge(a.v,a.w,a.name);i.l.info("Edge data",E,c);try{((n,e)=>(i.l.info("Descendants of ",e," is ",h[e]),i.l.info("Edge is ",n),n.v!==e&&n.w!==e&&(h[e]?h[e].includes(n.v)||P(n.v,e)||P(n.w,e)||h[e].includes(n.w):(i.l.debug("Tilt, ",e,",not in descendants"),!1))))(a,c)?(i.l.info("Copying as ",a.v,a.w,E,a.name),t.setEdge(a.v,a.w,E,a.name),i.l.info("newGraph edges ",t.edges(),t.edge(t.edges()[0]))):i.l.info("Skipping copy of edge ",a.v,"--\x3e",a.w," rootId: ",c," clusterId:",n)}catch(C){i.l.error(C)}})}i.l.debug("Removing node",r),e.removeNode(r)})},j=(n,e)=>{const t=e.children(n);let c=[...t];for(const s of t)v[s]=n,c=[...c,...j(s,e)];return c},M=(n,e)=>{i.l.trace("Searching",n);const t=e.children(n);if(i.l.trace("Searching children of id ",n,t),t.length<1)return i.l.trace("This is a valid node",n),n;for(const c of t){const s=M(c,e);if(s)return i.l.trace("Found replacement for",n," => ",s),s}},L=n=>l[n]&&l[n].externalConnections&&l[n]?l[n].id:n,J=(n,e)=>{if(i.l.warn("extractor - ",e,m.c(n),n.children("D")),e>10)return void i.l.error("Bailing out");let t=n.nodes(),c=!1;for(const s of t){const r=n.children(s);c=c||r.length>0}if(c){i.l.debug("Nodes = ",t,e);for(const s of t)if(i.l.debug("Extracting node",s,l,l[s]&&!l[s].externalConnections,!n.parent(s),n.node(s),n.children("D")," Depth ",e),l[s])if(!l[s].externalConnections&&n.children(s)&&n.children(s).length>0){i.l.warn("Cluster without external connections, without a parent and with children",s,e);let f="TB"===n.graph().rankdir?"LR":"TB";l[s]&&l[s].clusterData&&l[s].clusterData.dir&&(f=l[s].clusterData.dir,i.l.warn("Fixing dir",l[s].clusterData.dir,f));const u=new R.k({multigraph:!0,compound:!0}).setGraph({rankdir:f,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.l.warn("Old graph before copy",m.c(n)),U(s,n,u,s),n.setNode(s,{clusterNode:!0,id:s,clusterData:l[s].clusterData,labelText:l[s].labelText,graph:u}),i.l.warn("New graph after copy node: (",s,")",m.c(u)),i.l.debug("Old graph after copy",m.c(n))}else i.l.warn("Cluster ** ",s," **not meeting the criteria !externalConnections:",!l[s].externalConnections," no parent: ",!n.parent(s)," children ",n.children(s)&&n.children(s).length>0,n.children("D"),e),i.l.debug(l);else i.l.debug("Not a cluster",s,e);t=n.nodes(),i.l.warn("New list of nodes",t);for(const s of t){const r=n.node(s);i.l.warn(" Now next level",s,r),r.clusterNode&&J(r.graph,e+1)}}else i.l.debug("Done, no node has children",n.nodes())},Z=(n,e)=>{if(0===e.length)return[];let t=Object.assign(e);return e.forEach(c=>{const s=n.children(c),r=Z(n,s);t=[...t,...r]}),t},H={rect:(n,e)=>{i.l.info("Creating subgraph rect for ",e.id,e);const t=(0,i.c)(),c=n.insert("g").attr("class","cluster"+(e.class?" "+e.class:"")).attr("id",e.id),s=c.insert("rect",":first-child"),r=(0,i.m)(t.flowchart.htmlLabels),f=c.insert("g").attr("class","cluster-label"),u="markdown"===e.labelType?(0,p.a)(f,e.labelText,{style:e.labelStyle,useHtmlLabels:r}):f.node().appendChild((0,g.c)(e.labelText,e.labelStyle,void 0,!0));let a=u.getBBox();if((0,i.m)(t.flowchart.htmlLabels)){const y=u.children[0],d=(0,A.Ys)(u);a=y.getBoundingClientRect(),d.attr("width",a.width),d.attr("height",a.height)}const E=0*e.padding,C=E/2,D=e.width<=a.width+E?a.width+E:e.width;e.diff=e.width<=a.width+E?(a.width-e.width)/2-e.padding/2:-e.padding/2,i.l.trace("Data ",e,JSON.stringify(e)),s.attr("style",e.style).attr("rx",e.rx).attr("ry",e.ry).attr("x",e.x-D/2).attr("y",e.y-e.height/2-C).attr("width",D).attr("height",e.height+E);const{subGraphTitleTopMargin:N}=(0,g.g)(t);f.attr("transform",r?`translate(${e.x-a.width/2}, ${e.y-e.height/2+N})`:`translate(${e.x}, ${e.y-e.height/2+N})`);const T=s.node().getBBox();return e.width=T.width,e.height=T.height,e.intersect=function(y){return(0,g.i)(e,y)},c},roundedWithTitle:(n,e)=>{const t=(0,i.c)(),c=n.insert("g").attr("class",e.classes).attr("id",e.id),s=c.insert("rect",":first-child"),r=c.insert("g").attr("class","cluster-label"),f=c.append("rect"),u=r.node().appendChild((0,g.c)(e.labelText,e.labelStyle,void 0,!0));let a=u.getBBox();if((0,i.m)(t.flowchart.htmlLabels)){const y=u.children[0],d=(0,A.Ys)(u);a=y.getBoundingClientRect(),d.attr("width",a.width),d.attr("height",a.height)}a=u.getBBox();const E=0*e.padding,C=E/2,D=e.width<=a.width+e.padding?a.width+e.padding:e.width;e.diff=e.width<=a.width+e.padding?(a.width+0*e.padding-e.width)/2:-e.padding/2,s.attr("class","outer").attr("x",e.x-D/2-C).attr("y",e.y-e.height/2-C).attr("width",D+E).attr("height",e.height+E),f.attr("class","inner").attr("x",e.x-D/2-C).attr("y",e.y-e.height/2-C+a.height-1).attr("width",D+E).attr("height",e.height+E-a.height-3);const{subGraphTitleTopMargin:N}=(0,g.g)(t);r.attr("transform",`translate(${e.x-a.width/2}, ${e.y-e.height/2-e.padding/3+((0,i.m)(t.flowchart.htmlLabels)?5:3)+N})`);const T=s.node().getBBox();return e.height=T.height,e.intersect=function(y){return(0,g.i)(e,y)},c},noteGroup:(n,e)=>{const t=n.insert("g").attr("class","note-cluster").attr("id",e.id),c=t.insert("rect",":first-child"),s=0*e.padding,r=s/2;c.attr("rx",e.rx).attr("ry",e.ry).attr("x",e.x-e.width/2-r).attr("y",e.y-e.height/2-r).attr("width",e.width+s).attr("height",e.height+s).attr("fill","none");const f=c.node().getBBox();return e.width=f.width,e.height=f.height,e.intersect=function(u){return(0,g.i)(e,u)},t},divider:(n,e)=>{const t=n.insert("g").attr("class",e.classes).attr("id",e.id),c=t.insert("rect",":first-child"),s=0*e.padding,r=s/2;c.attr("class","divider").attr("x",e.x-e.width/2-r).attr("y",e.y-e.height/2).attr("width",e.width+s).attr("height",e.height+s);const f=c.node().getBBox();return e.width=f.width,e.height=f.height,e.diff=-e.padding/2,e.intersect=function(u){return(0,g.i)(e,u)},t}};let F={};const G=function(){var n=(0,b.Z)(function*(e,t,c,s,r,f){i.l.info("Graph in recursive render: XXX",m.c(t),r);const u=t.graph().rankdir;i.l.trace("Dir in recursive render - dir:",u);const a=e.insert("g").attr("class","root");t.nodes()?i.l.info("Recursive render XXX",t.nodes()):i.l.info("No nodes found for",t),t.edges().length>0&&i.l.trace("Recursive edges",t.edge(t.edges()[0]));const E=a.insert("g").attr("class","clusters"),C=a.insert("g").attr("class","edgePaths"),D=a.insert("g").attr("class","edgeLabels"),N=a.insert("g").attr("class","nodes");yield Promise.all(t.nodes().map(function(){var d=(0,b.Z)(function*(o){const w=t.node(o);if(void 0!==r){const B=JSON.parse(JSON.stringify(r.clusterData));i.l.info("Setting data for cluster XXX (",o,") ",B,r),t.setNode(r.id,B),t.parent(o)||(i.l.trace("Setting parent",o,r.id),t.setParent(o,r.id,B))}if(i.l.info("(Insert) Node XXX"+o+": "+JSON.stringify(t.node(o))),w&&w.clusterNode){i.l.info("Cluster identified",o,w.width,t.node(o));const B=yield G(N,w.graph,c,s,t.node(o),f),W=B.elem;(0,g.u)(w,W),w.diff=B.diff||0,i.l.info("Node bounds (abc123)",o,w,w.width,w.x,w.y),(0,g.s)(W,w),i.l.warn("Recursive render complete ",W,w)}else t.children(o).length>0?(i.l.info("Cluster - the non recursive path XXX",o,w.id,w,t),i.l.info(M(w.id,t)),l[w.id]={id:M(w.id,t),node:w}):(i.l.info("Node - the non recursive path",o,w.id,w),yield(0,g.e)(N,t.node(o),u))});return function(o){return d.apply(this,arguments)}}())),t.edges().forEach(function(d){const o=t.edge(d.v,d.w,d.name);i.l.info("Edge "+d.v+" -> "+d.w+": "+JSON.stringify(d)),i.l.info("Edge "+d.v+" -> "+d.w+": ",d," ",JSON.stringify(t.edge(d))),i.l.info("Fix",l,"ids:",d.v,d.w,"Translating: ",l[d.v],l[d.w]),(0,g.f)(D,o)}),t.edges().forEach(function(d){i.l.info("Edge "+d.v+" -> "+d.w+": "+JSON.stringify(d))}),i.l.info("#############################################"),i.l.info("###                Layout                 ###"),i.l.info("#############################################"),i.l.info(t),(0,S.bK)(t),i.l.info("Graph after layout:",m.c(t));let T=0;const{subGraphTitleTotalMargin:y}=(0,g.g)(f);return(n=>Z(n,n.children()))(t).forEach(function(d){const o=t.node(d);i.l.info("Position "+d+": "+JSON.stringify(t.node(d))),i.l.info("Position "+d+": ("+o.x,","+o.y,") width: ",o.width," height: ",o.height),o&&o.clusterNode?(o.y+=y,(0,g.p)(o)):t.children(d).length>0?(o.height+=y,((n,e)=>{i.l.trace("Inserting cluster"),F[e.id]=H[e.shape||"rect"](n,e)})(E,o),l[o.id].node=o):(o.y+=y/2,(0,g.p)(o))}),t.edges().forEach(function(d){const o=t.edge(d);i.l.info("Edge "+d.v+" -> "+d.w+": "+JSON.stringify(o),o),o.points.forEach(B=>B.y+=y/2);const w=(0,g.h)(C,d,o,l,c,t,s);(0,g.j)(o,w)}),t.nodes().forEach(function(d){const o=t.node(d);i.l.info(d,o.type,o.diff),"group"===o.type&&(T=o.diff)}),{elem:a,diff:T}});return function(t,c,s,r,f,u){return n.apply(this,arguments)}}(),Q=function(){var n=(0,b.Z)(function*(e,t,c,s,r){(0,g.a)(e,c,s,r),(0,g.b)(),(0,g.d)(),F={},h={},v={},l={},i.l.warn("Graph at first:",JSON.stringify(m.c(t))),((n,e)=>{if(n){i.l.debug("Opting in, graph "),n.nodes().forEach(function(t){n.children(t).length>0&&(i.l.warn("Cluster identified",t," Replacement id in edges: ",M(t,n)),h[t]=j(t,n),l[t]={id:M(t,n),clusterData:n.node(t)})}),n.nodes().forEach(function(t){const c=n.children(t),s=n.edges();c.length>0?(i.l.debug("Cluster identified",t,h),s.forEach(r=>{r.v!==t&&r.w!==t&&P(r.v,t)^P(r.w,t)&&(i.l.warn("Edge: ",r," leaves cluster ",t),i.l.warn("Descendants of XXX ",t,": ",h[t]),l[t].externalConnections=!0)})):i.l.debug("Not a cluster ",t,h)});for(let t of Object.keys(l)){const s=n.parent(l[t].id);s!==t&&l[s]&&!l[s].externalConnections&&(l[t].id=s)}n.edges().forEach(function(t){const c=n.edge(t);i.l.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),i.l.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(n.edge(t)));let s=t.v,r=t.w;if(i.l.warn("Fix XXX",l,"ids:",t.v,t.w,"Translating: ",l[t.v]," --- ",l[t.w]),l[t.v]&&l[t.w]&&l[t.v]===l[t.w]){i.l.warn("Fixing and trixing link to self - removing XXX",t.v,t.w,t.name),i.l.warn("Fixing and trixing - removing XXX",t.v,t.w,t.name),s=L(t.v),r=L(t.w),n.removeEdge(t.v,t.w,t.name);const f=t.w+"---"+t.v;n.setNode(f,{domId:f,id:f,labelStyle:"",labelText:c.label,padding:0,shape:"labelRect",style:""});const u=structuredClone(c),a=structuredClone(c);u.label="",u.arrowTypeEnd="none",a.label="",u.fromCluster=t.v,a.toCluster=t.v,n.setEdge(s,f,u,t.name+"-cyclic-special"),n.setEdge(f,r,a,t.name+"-cyclic-special")}else if(l[t.v]||l[t.w]){if(i.l.warn("Fixing and trixing - removing XXX",t.v,t.w,t.name),s=L(t.v),r=L(t.w),n.removeEdge(t.v,t.w,t.name),s!==t.v){const f=n.parent(s);l[f].externalConnections=!0,c.fromCluster=t.v}if(r!==t.w){const f=n.parent(r);l[f].externalConnections=!0,c.toCluster=t.w}i.l.warn("Fix Replacing with XXX",s,r,t.name),n.setEdge(s,r,c,t.name)}}),i.l.warn("Adjusted Graph",m.c(n)),J(n,0),i.l.trace(l)}else i.l.debug("Opting out, no graph ")})(t),i.l.warn("Graph after:",JSON.stringify(m.c(t)));const f=(0,i.c)();yield G(e,t,s,r,void 0,f)});return function(t,c,s,r,f){return n.apply(this,arguments)}}()}}]);